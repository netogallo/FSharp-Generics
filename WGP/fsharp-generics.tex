%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{listings}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Generic Programming in F\#}
\subtitle{Datatype generic programming for .Net}

\authorinfo{Ernesto Rodriguez}
           {Utrecht University}
           {e.rodriguez@students.uu.nl}
\authorinfo{Wouter Swierstra}
           {Utrecht University}
           {W.S.Swierstra@uu.nl}

\maketitle

\begin{abstract}
The introduction of Datatype Generic programming (DGP) *revolutionized* functional programming by allowing numerous algorithms to be defined by induction over the structure of types while still providing type safety. Due to the advanced type system requirements for DGP, only a handful of functional languages can define generic functions making it inaccessible to most programmers. Ordinary languages provide reflection and duck typing as a mechanism to specify generic algorithms. These mechanisms are usually error prone and verbose. By combining ideas from DGP and implementing them through reflection, a type-safe interface to DGP has been built for the F\# language. These generic algorithms can be accessed by any language running in the .Net platform.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

\section{Background}
\subsection{The F\# Language}
The F\# programming language is a functional language of the ML family. It focuses on being a productive language by levering on functional programming and at the same time easy to adopt by programmers of other .Net hosted languages. As a result, the lenguage has a much simpler type system than Haskell or Scala. Most of the development effort in the language has focused on features to work with data (like type-providers) and to be compatible with the .Net type system. Unlike Scala, F\# performs no type errasure when compiled to the .Net platform.
\\\\
There are several mechanism to define new types in F\#: classes, records and algebraic data types. Classes correspond to the traditional object oriented paradigm and are allowed to inherit fields and functions from another type as long as the type is not sealed (which is a .Net attribute for types). Records and algebraic datatypes correspond to the functional approach of defining types. Records and ADTs are always sealed and can be pattern matched. All types in F\# can define member functions (methods) and can implement any number of interfaces. Types can also have generic type arguments but they are required to be of kind $*$ (star).
\subsection{The .Net platform}
The .Net platform is a common runtime environment to allow the execution of a family of languages. It implements a very rich type system which includes support for generics. Many type operations that happen in F\# (such as sub-typeing) are handled by the .Net platform. The sub-typeing relation will be denoted by $\tau_a :> \tau_b$ which means $\tau_a$ is a sub-type of $\tau_b$ and consequently a value of type $\tau_a$ can be automatically converted to a value of type $\tau_b$.
\\\\
Like most object oriented langagues, .Net sub-typeing mechanism that allows types to be automatically converted to types which are higher in the class hierarchy. The F\# language uses the keyword \verb+inherit+ to denote that a type inherits from another type. A well known restriction of this mechanism is that sub-typeing rules cannot automatically be applied to generic type arguments. In other words $\tau_a :> \tau_b\ \not\Rightarrow\ T<\tau_a> \ :> \ T<\tau_b>$.
\\\\
The .Net platform internally uses an abstract class \verb+Type+ to represent any of the types that are available. This class implements operations such as casting or instantiating the generic type arguments of a type. At runtime, any value can be queried for it's type and the program under execution can use this information and even produce new types while running. This collection of mechanisms is know nas reflection.
\\\\
Since the \verb+Type+ class is not sealed. Languages can extend it with any information they want. This allows F\# to include metadata specific for functional programming. Using this metadata, it is possible to determine at runtime what are the type constructors of an ADT and even pattern match the type on those constructors. It is also possible to invoke the constructor with the appropiate values to produce new values. It should be noted that doing so is not type safe since the compiler cannot check that the operations being preformed are safe and type errors will lead to runtime exceptions. Nevertheless, this mechanism is actively used in libraries such as FsPickler \cite{FsPickler} which is a general purpose .Net serializer.

\section{Type Representations in F\#}
The essence of DGP is to provide an abstraction that is able to treat values of different types and equivalent structure as equivalent while still providing type safety. Type representations are used to achieve that objective. The method used here is similar to the approach from Regular\cite{Regular} but had to be adapted to cope with two of F\#'s limitations:
\begin{itemize}
\item Generics of higher kind are not permitted in F\# (nor .Net)
\item Method calls must be resolved statically
\end{itemize}
All type representations are a sub-class of the \verb+Meta+ abstract class. It's main role is imposing type constraints on generics that are required to be a type-representation. Those constraints serve as an alternative to typeclass constraints that are used in Regular. For instance in Regular one might have:
\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\fontfamily{lmvtt}\selectfont,
]
instance (GenericClass a,GenericClass b) => GenericClass (a :*: b) where
  genericFunction x = ...
\end{lstlisting}
which in F\# would translate to a class:
\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\fontfamily{lmvtt}\selectfont,
]
type GenericClass =
  member genericFunction<'a,'b when 'a :> Meta and 'b :> Meta> (x : Prod<'a,'b>) = ...
\end{lstlisting}
and this indicates that \verb+'a+ and \verb+'b+ must be a type representation. Later one will see that the constraints not need to appear in the signature of \verb+genericFunction+ because they are added to the \verb+Prod+ class itself (which is also shown later).
\\\\
The first sub-class of \verb+Meta+ is \verb+SumConstr+. This is used to represent the possible type constructors that an algebraic data type has. This type takes three type arguments: \verb+t+,\verb+a+ and \verb+b+. The first one indicates the type that this representation encodes (or \verb+unit+ when it is an intermediate representation). The \verb+'a+ argument corresponds to the type representation of values created by one of the type constructors. The \verb+b+ argument contains the representation of the remaining type constructors or serves the same role as \verb+'a+ to represent values created with the last type constructor. Both \verb+'a+ and \verb+'b+ have the constraint $\mathtt{'a},\mathtt{'b} :> \mathtt{Meta}$. For instance suppose one has a type \verb+type Elems<'a> = Cons of a*Elems<'a> | Val of 'a | Nil+ its representation would look like: \verb+type ElemsRep<'a> = SumConstr<Elem<'a>,_,SumConstr<_,_>>+.
\\\\
The second sub-class of \verb+Meta+ is \verb+Prod+. This type is used to represent cases in which a type constructor accepts more than one argument. The \verb+Prod+ type accepts two type arguments: \verb+'a+ and \verb+'b+. The first argument contains the type representation of one of the constructor's parameters. The second argument contains the representation of the remaining constructor's arguments or the type \verb+U+ which is used to denote emptyness. Both \verb+'a+ and \verb+'b+ have the constraint $\mathtt{'a},\mathtt{'b} :> \mathtt{Meta}$. With this constructor it is possible to fill the blanks of \verb+ElemsRep+ as follows:
\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\fontfamily{lmvtt}\selectfont,
]
type ElemsRep<'a> = SumConstr<
  Elem<'a>,
  SumConstr<
    Prod<_,Prod<_,U>>,
    SumConstr<
      Prod<_,U>,
      U>>>
\end{lstlisting}
The third sub-class of \verb+Meta+ is \verb+K+. This type is used to represent a type that is not an ADT. Such types cannot be generically manipulated with DGP, nevertheless it is possible to write algorithms that operate on ocurrences of a particular type(s) inside a ADT. The \verb+K+ constructor takes a single type argument \verb+'a+ which corresponds to the type of its content. Since F\# cannot statically constrain a type to be or not to be an ADT, \verb+'a+ has no constraints. To continue with the example above, the type \verb+Elem<int>+ would be represented as:
\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\fontfamily{lmvtt}\selectfont,
]
type ElemsRep = SumConstr<
  Elem<int>,
  SumConstr<
    Prod<K<int>,Prod<_,U>>,
    SumConstr<
      Prod<K<int>,U>,
      U>>>
\end{lstlisting}
The fourth sub-class of \verb+Meta+ is \verb+Id+. This type is used to represent recursion within a type. This is necessary otherwise a type representation would be infinite for recursive ADTs. This type takes a single type argument which is the which is the same type being represented. With this addition, \verb+Elem<int>+ is now represented as follows:
\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\fontfamily{lmvtt}\selectfont,
]
type ElemsRep = SumConstr<
  Elem<int>,
  SumConstr<
    Prod<K<int>,Prod<Id<Elem<int>>,U>>,
    SumConstr<
      Prod<K<int>,U>,
      U>>>
\end{lstlisting}
The last sub-class of \verb+Meta+ is \verb+U+. This type is used to represent an empty argument in a type constructor. That is the reason the \verb+Nil+ constructor is represented as \verb+U+ and ocurrences of \verb+Prod+ will always have \verb+U+ as the second argument of the innermost \verb+Prod+.
\section{Generic Functions}
The purpose of type representations is to provide an interface that the programmer can use to define generic functions. In other words is a language to define what the semantics of such functions are. The library will then be provided with a generic function definition and will apply it as appropiate to the values it is provided with.
The F\# language does not support generics of higher kind. This means that generic types in F\# cannot be applied to other types. This feature is used by other DGP \cite{Regular,MultiRec,GenericDeriving,RepLib} to enforce type safety and allow the compiler to select  

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

